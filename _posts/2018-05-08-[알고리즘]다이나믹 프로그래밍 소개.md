---
layout: post
title:  "[코드스쿼드] Lv2 과제"
subtitle:   "코드스쿼드"
categories: devlog
tags: algorithm
comments: true
---

- ### 다이나믹 프로그래밍이란?

  큰 문제를 작은 문제로 나눠서 푸는 알고리즘

  Dynamic Programming의 Dynamic은 아무의미가 없음

  즉, 동적계획법의 동적이란 의미가 아님!

  (1940년 Richard Bellman은 멋있어보여서 사용함)

  ​

- ### 다이나믹 프로그래밍의 조건

  1. Overlapping Subproblem (겹치는 부분문제)
  2. Optimal Substructure (문제의 정답을 작은 문제의 부분에서 구할 수 있을 때)



- ### Overlapping Subproblem

  `문제를 작은 부분문제로 나눠서 푸는것이 핵심`

  - #### 피보나치 수

    F0 = 0, F1 = 1 일 때,

    Fn = Fn-1 + Fn-2 ( n>=2 )

    문제 : **N번째 피보나치 수를 구하는 문제**

    작은 문제 : **N-1번째 피보나치 수를 구하는 문제**, N-2번째 피보나치 수를 구하는 문제

    문제 : N-1번째 피보나치 수를 구하는 문제

    작은 문제 : **N-2번째 피보나치 수를 구하는 문제**, N-3번째 피보나치 수를 구하는 문제

    문제 : **N-2번째 피보나치 수를 구하는 문제**

    작은 문제 : N-3번째 피보나치 수를 구하는 문제, N-4번째 피보나치 수를 구하는 문제

  - #### 결론

    - 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다
    - 문제를 작은 문제로 쪼갤 수 있다



- ### Optimal Substructure

  `문제의 정답을 작은 문제의 정답에서 구할 수 있다`

  - 예시

    `서울`에서 `부산`을 가는 가장 빠른 길이 `대전과 대구를 순서대로 거쳐야 한다`면

    `대전`에서 `부산`을 가는 가장 빠른 길은 `대구`를 거쳐야 한다

  - 피보나치

    **문제의 정답을 작은 문제의 정답을 합하는 것으로 구할 수 있다**

  - 결론

    Optimal Substructure를 만족한다면, 문제의 크기에 상관없이 `어떤 한 문제의 정답은 일정`함

    10번 째 피보나치 수를 구하면서 구한 **4번째 피보나치 수**

    9번 째 피보나치 수를 구하면서 구한 **4번째 피보나치 수**

    ...

    5번 째 피보나치 수를 구하면서 구한 **4번째 피보나치 수**

    4번 째 피보나치 수를 구하면서 구한 **4번째 피보나치 수**

    `즉, 4번째 피보나치 수는 항상 같다`



- ### 다이나믹 프로그래밍

  - 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다.
  - Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 때 마다 정답이 같다
  - 따라서, 정답을 한번 구했으면, 정답을 어딘가에 메모해놓는다.
  - 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다
  - 메모를 한다고 해서 영어로 `Memoization`이라고 한다
    - 배열에다가 저장하는 방식으로 구현