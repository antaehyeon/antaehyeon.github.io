---
# Posts need to have the `post` layout
layout: post

# The title of your post
title: 정보처리기사 3단원 운영체제 틀린문제 정리

# (Optional) Write a short (~150 characters) description of each blog post.
# This description is used to preview the page on search engines, social media, etc.
description: >

# (Optional) Link to an image that represents your blog post.
# The aspect ratio should be ~16:9.
image: /assets/img/default.jpg

# You can hide the description and/or image from the output
# (only visible to search engines) by setting:
# hide_description: true
# hide_image: true

# (Optional) Each post can have zero or more categories, and zero or more tags.
# The difference is that categories will be part of the URL, while tags will not.
# E.g. the URL of this post is <site.baseurl>/hydejack/2017/11/23/example-content/
categories: [hydejack]
tags: [example, content]
# If you want a category or tag to have its own page,
# check out `_featured_categories` and `_featured_tags` respectively.
---

# 정보처리기사 3단원

### 1장. 시스템 소프트웨어의 구성

![](https://imgur.com/5YYhqPm.png)

![](https://imgur.com/xsIB2VS.png)

![](https://imgur.com/p7ZYjog.png)

- PCB : 프로세스에 할당된 자원에 대한 정보
  - 프로세스 **상태**
  - 프로그램 카운터 (Program Counter)
  - 프로세스 **우선순위**
  - 중앙처리장치 레지스터 보관 장소
  - 프로세스 고유 구별자
  - 부모, 자식 프로세스에 대한 포인터
  - 부모 프로세스와 자식 프로세스는 PCB 를 공유 X
  - 프로세스의 사용빈도 X
  - 프로세스의 생성 정보 X
  - 파일 할당 테이블 X
  - 할당되지 않은 주변장치의 상태정보 X



![](https://imgur.com/cScgg9T.png)

![](https://imgur.com/l0drTCN.png)

![](https://imgur.com/5gKyMsN.png)

- 시분할 시스템 (Time Sharing)
  - 여러명의 사용자가 사용하는 시스템에서
  - 컴퓨터가 사용자들의 프로그램을 번갈아가며 처리
  - 각 사용자에게 독립된 컴퓨터를 사용하는 느낌을 줌
  - 하드웨어를 능률적으로 사용
  - 라운드 로빈 방식
  - CPU는 작업시간량 (Time Slice, **Quantum**) 을 나누어 정해진 시간동안 번갈아가며 처리
    - 처리기를 작업시간량 (Time Slice) 으로 나누는것 X
    - 둘 이상의 CPU X
  - 다중프로그래밍을 결합해 대화식 처리(모든 작업이 동시진행)가 가능



![](https://imgur.com/Nm9xYic.png)

- 크로스 어셈블러 : 다른 컴퓨터를 이용한 어셈블리어 번역



![](https://imgur.com/NAVK6IH.png)

- 클러스터 (Cluster) : 전체 컴퓨터들이 상호연결되어 협력하면서 하나의 컴퓨팅 지원인 것처럼 동작



![](https://imgur.com/6ZJgqPS.png)

![](https://imgur.com/phsXXGr.png)

![](https://imgur.com/6NA1XsL.png)

![](https://imgur.com/lgS0IiZ.png)

- 로더 (**L**oader)

  ```
  보조기억장치로부터 주기억장치에 올려놓는 기능
  ```

  - 기능 `LARLL`
    - 할당 (**A**llocation) : 공간확보 (주체는 프로그래머)
    - 연결 (**L**inking) : (주체는 프로그래머)
    - 재배치 (**R**elocation) : (주체는 언어번역 프로그램)
    - 적재 (**L**oading) : (주체는 로더)
  - 종류
    - Compile And **Go** Loader
      - 별도의 로더 없음
      - **언어번역 프로그램**이 로더역할 담당
    - **절대** 로더 (Absolute Loader) `절대적인`
      - 로더의 역할 축소
      - 기억장소 할당 및 연결을 **프로그래머가 직접 지정** (매우 어려움)
      - 목적프로그램을 **기억장소에 적재시키는 역할**만 담당
      - 한번 지정한 주기억장소의 위치는 변경이 힘듬
    - **동적** 적재 로더 (Dynamic Loading Loader)
      - 실행 시 **필요한 일부분**만을 **적재**하는 로더



![](https://imgur.com/e9bwBQg.png)

![](https://imgur.com/b9CnHuw.png)

![](https://imgur.com/F27FieI.png)

![](https://imgur.com/bpbDhoc.png)

![](https://imgur.com/VWX2EFR.png)

- 프로세스
  - **실행중**인 프로그램
  - **PCB**를 가진 프로그램
  - **프로시저**가 활동중인 것
  - **비동기적 행위**를 일으키는 주체
  - 오류에 대한 조치는 X



![](https://imgur.com/sPUZNnI.png)

![](https://imgur.com/Viv4hoq.png)

![](https://imgur.com/J8n5xXD.png)

![](https://imgur.com/92513wm.png)

![](https://imgur.com/BoPiuwR.png)
![](https://imgur.com/8y7EKfJ.png)

![](https://imgur.com/8MFNkkN.png)



- 운영체제
  - 일종의 소프트웨어 장치
  - 사용자와 시스템 간 인터페이스
  - 기능
    - 입출력 장치 및 프로세스 관리
    - 스케줄링 (디스크 스케줄링은 X)
    - 자원공유
    - 자원보호
    - 프로세스 생성 제거 X
    - 중지 및 수행 X
    - 언어번역 X
    - JAVA X
    - 유지관리 X
    - 입출력 주력 X
  - 목적
    - 처리능력 - Throughput - 일정시간내 시스템이 처리하는 일의 양
    - 신뢰도 - Reliability
    - 사용 가능도 향상 - Availability - 사용자가 요구할 때 **어느정도 신속하게 지원**하는가
    - 변환 시간 (Turn Around Time) 단축
  - 발달 과정 `일시다분`
    1. **일괄**처리 시스템
    2. 다중처리, 시분할, 실시간 시스템
    3. 다중모드 시스템
    4. **분산**처리 시스템
  - 인터프리터
    - BASIC, SNOBAL



![](https://imgur.com/J85pLBH.png)

- 제어 프로그램

  ```
  다른 업무로의 이행을 자동적으로 수행하기 위한 준비 및 처리 완료를 담당하는 기능
  ```

  - **감시** 프로그램
  - **작업 제어** 프로그램
  - **작업(데이터) 관리** 프로그램 : 자료 전송, 파일의 조작 및 처리 담당
  - 외에는 처리 프로그램



![](https://imgur.com/fDErnMf.png)

- 다중 처리 (Multi-processing) 시스템
  - CPU를 여러개 두고 동시에 프로그램을 수행

---

### 2장. 스레드

![](https://imgur.com/UEDVase.png)

- 프로세스의 주요 상태
  - 준비 (Ready)
  - 실행 (Running)
  - 대기 (Waiting)
  - 종료 (Exit)



![](https://imgur.com/hu4Ejdq.png)

- 적응 기법의 개념을 적용 : MFQ



![](https://imgur.com/YWDGrln.png)

![](https://imgur.com/qmm46nV.png)

![](https://imgur.com/vNSCFNw.png)

![](https://imgur.com/e43FB5w.png)

- 라운드 로빈 (Round Robin, RR) 은 프로세스들 사이에 우선순위를 두지 않고 **시간단위 (Time Slice/Quantum) 으로 CPU를 할당**
  - Time Sharing System 을 위해 고안된 방식
  - 시간 할당량이 커지면 FCFS 스케줄링과 같은 효과
  - 시간 할당량이 작아지면 프로세스 문맥교환 (오버헤드) 이 자주 일어남



![](https://imgur.com/bIuq0Tv.png)

![](https://imgur.com/PlzLTkp.png)
![](https://imgur.com/VNPBVQK.png)

- 위 문제 **답 4번**임 (하나의 프로세스에 여러개의 스레드가 존재할 수 있음)


- 스레드
  - 하나의 프로세스 내에서 시스템의 여러 자원을 할당받아 실행하는 프로그램 단위
  - 오버헤드 (프로세스의 생성 및 문맥교환)가 줄어 운영체제 성능 개선
  - 동일 프로세스 환경에서 독립적인 다중 수행 가능
  - 사용자 수준의 스레드는 사용자의 라이브러리를 사용하여 운용
    - 커널에 의한 스레드 운용 X
  - 하나의 프로세스에는 여러개의 스레드가 존재 = 병행성 증진
  - 스레드는 독립된 제어흐름을 가지며 고유 레지스터 사용
    - 레지스터를 모든 스레드들이 공유 X
  - 프로세스 내부에만 존재



![](https://imgur.com/xsQ0Bfs.png)

- HRN 방식
  - SJF 를 보완하기 위한 기법
  - 우선순위 계산식 : (대기시간 + 서비스시간) / 서비스시간
    - 클수록 우선순위가 높음



![](https://imgur.com/uSCtB4a.png)

![](https://imgur.com/D3VDx7f.png)

- SJF 정책
  - **실행시간이 가장 짧은** 프로세스에게 먼저 CPU를 할당
  - 실행시간 주정치가 가장 작은 작업을 먼저 실행
  - 제출시간인지 도착시간인지 정확히 확인할 것
    - 제출시간이라면 실행시간-제출시간



![](https://imgur.com/2CWE7xS.png)

- 선점 기법
  - 우선순위가 높은 프로세스를 빠르게 처리
  - 대화식 시분할 시스템 (빠른 응답시간을 요구하는) 에 사용
  - 선점으로 인한 많은 오버헤드가 초래
  - 인터럽트용 타이머 (선점을 위해 시간 배당을 위한) 클럭이 필요
  - 종류
    - SRT
    - RR
    - 다단계 큐
    - 다단계 피드백 큐 (MFQ)
    - 선점 우선순위
- 비선점 스케줄링 기법
  - 이미 할당된 CPU를 다른 프로세스가 강제로 뺏어 사용할 수 없는 **공정한 기법**
  - 응답 시간 예측이 용이
  - 종류
    - FIFO(FCFS)
    - SJF
    - 우선순위
    - HRN
    - 기한부



![](https://imgur.com/3s3atJ5.png)

- FCFS (=FIFO)
  - 먼저 도착한 것을 먼저 처리
  - 최대 평균 반환시간
    - (12+(12+9)+(12+9+6)) / 3 = 20
  - 최소 평균 반환시간
    - (6+(6+9)+(6+9+12)) / 3 = 16


---

### 3장

![](https://imgur.com/pWm2pyz.png)

![](https://imgur.com/092B57e.png)

![](https://imgur.com/HXxZJrg.png)

![](https://imgur.com/EflEItO.png)

![](https://imgur.com/8zobv1y.png)

![](https://imgur.com/1F9XJkx.png)

![](https://imgur.com/ym6mzVa.png)

![](https://imgur.com/qHd0nRe.png)



- ### 기억장치 관리 전략 `FPR`

  -  반입 (**F**etch) 전략
    - 주기억장치로 언제 적재할 것인지 결정
  -  배치 (**P**lacement) 전략
    - 최초 적합 (First Fit)
    - 최적 적합 (Best Fit)
    - 최악 적합 (Worst Fit)
    - 10K 프로그램
      - First Fit : **15K**인 영역2
      - Best Fit : **10K**인 영역3
      - Worst Fit : **30K**인 영역4
    - 10K 프로그램이지만 각 상태가 존재할 경우
      - 사용 중인 영역은 건너뛰고
      - 영역 크기가 프로그램보다 작으면 건너뛰고
      - **15K인 영역C에서 First Fit 이 사용됨**
    - 내부 단편화
      - 저장되는 공간이 더 커서
      - 저장된 내용을 뺀 나머지 부분
    - 외부 단편화
      - 저장되는 내용이 공간보다 더 커서
      - 그 공간을 사용하지 못한 부분
    - **각각** 사용할때에는 최초, 최적, 최악을 하나의 경우로 생각하면 됨
  -  교체 (**R**eplacement) 전략
    - 페이지교체 알고리즘을 이용


![](https://imgur.com/HRJoYz3.png)

![](https://imgur.com/cQ3jt7q.png)

![](https://imgur.com/emcUc2x.png)

![](https://imgur.com/5uCL6fh.png)

- ### 교착상태(DeadLock)

  ```
  자원을 점유한 상태에서 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상
  ```

  - #### 발생 (필요 충분) 조건

    - 상호 배제 (Mutual Exclusion)
      - 한번에 한 프로세스만 자원 사용
    - 점유와 대기 (Hold & Wait)
      - 다른 자원이 할당되기를 기다리는동안
      - 이미 확보한 자원을 계속 보유하고 있음
    - 비선점 (Non-Preemptive)
      - 강제로 빼앗을 수 없음
    - 환영 대기 (Circular Wait)
      - 서로간의 요구관계가 회전

  - #### 해결 방법

    - **예방 (Prevention) 기법**
      - 상호 배제 부정
      - 점유 및 대기 부정
        - 프로세스가 실행되기 전
        - 필요한 모든 자원을 할당하여
        - 프로세스 대기를 없애거나
        - 자원이 점유되지 않은 상태에서만
        - 자원을 요구하도록 함
      - 비선점 부정
      - 환영대기 부정
    - **회피 (Avoidance) 기법**
      - 교착상태가 발생하면 적절히 피해나가는 방법
      - 주로 은행원 **Banker** 알고리즘에 사용
      - 불안전 상태 (교착상태가 발생할 수 있는 상태)
        - 모든 시스템이 교착상태는 아님
      - 교착상태를 완전히 배제하진 않음
      - 사전에 교착상태를 배제하지 않음
    - **발견 (Detection) 기법**
      - 시스템에 교착상태가 발생했는지 점검
        - 이후 교착상태가 있는 프로세스와 자원 발견
      - 자원할당 그래프를 이용
    - **회복 (Recovery) 기법**
      - 교착상태의 프로세스에 할당된 자원을 선점
      - 프로세스나 자원을 회복




![](https://imgur.com/Ghbhbsd.png)

![](https://imgur.com/EJujkgd.png)

- 임계 구역
  - 임계 구역에는 하나의 프로세스만 접근
  - 작업은 신속하게
  - 인터럽트 발생은 하지 않음



![](https://imgur.com/YhIE5gF.png)

- Test & Set 알고리즘 = 특수한 하드웨어 자원이 필요한 상호배제 기법

---

### 4장

![](https://imgur.com/HfdpFYc.png)

![](https://imgur.com/onGXYo7.png)

![](https://imgur.com/5zKx8bs.png)

- NUR (Not-Used-Recently) `안참조변`

  - 참조는 안되고 변형된 페이지를 우선적으로 교체함

  - 참조비트(Reference Bit) 와 변형비트(Modified Bit)를 이용

    | 참조 비트 | 변형 비트 |          내용           |
    | :-------: | :-------: | :---------------------: |
    |     0     |     0     |  가장 먼저 페이지 교체  |
    |     1     |     1     | 가장 나중에 페이지 교체 |



![](https://imgur.com/xcXkMyl.png)

![](https://imgur.com/1bFHnqU.png)

![](https://imgur.com/xQEuDkR.png)

- 내부 단편화
  - 저장되는 공간이 더 커서
  - 저장된 내용을 뺀 나머지 부분
- 외부 단편화
  - 저장되는 내용이 공간보다 더 커서
  - 그 공간을 사용하지 못한 부분
- 60K와 160K가 사용하지 못했으므로, 해당 공간의 크기 (50K + 120K) 를 계산하면 되므로 170K 이다
- Worst Fit 이므로, 40K-17K = 23K



![](https://imgur.com/6L36BCr.png)

- 세그먼테이션 (Segmentation)
  - 고유한 이름과 크기를 갖음
  - 작업의 크기를 서로 다르게 나누고
  - 기억장소 보호 방법으로
  - 기억장치 보호키를 사용
  - 외부 단편화 발생 가능
  - 세그먼트 맵 테이블 필요
    - 페이지의 맵 X



![](https://imgur.com/I0u2Vx6.png)

![](https://imgur.com/kH7nS4e.png)

![](https://imgur.com/YwX0bIr.png)

![](https://imgur.com/dtWXMcG.png)

![](https://imgur.com/uygqD60.png)

![](https://imgur.com/ZWOfb6d.png)

- 국부성 (=구역성 = Locality)
  - 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론
  - 캐시 메모리 시스템의 이론적인 근거
  - Denning 교수에 의해 증명됨
    - 어떤 프로그램의 참조 영역은 지역화 된다
- 시간적 구역성 (Temporal Locality)
  - 최근에 참조한 기억장소의 특정 부분은 그 후에도 계속 참조할 가능성이 높음을 의미함
  - Loop
  - 스택 (Stack)
  - 부프로그램 (Sub Program)
  - Counting
  - 집계 (Totaling)
  - 나머지는 공간구역성
  - 배열순회 X





![](https://imgur.com/vSnp3hl.png)

- 워킹셋
  - 데닝(Denning)이 제안
  - **일정시간 동안 자주 참조**하는
    - 시간에 따라 바뀌게 됨
  - 페이지들의 집합
  - 프로그램의 구역성(Logicality) 특징을 이용
  - 프로세스 수행에 소요되는 시간의 차이 X



![](https://imgur.com/1sSlhbq.png)

- LRU (Least Recently Used)
  - 최근에 **가장 오랫동안 사용하지 않은 페이지**를 교체
- B-C-B-A 순이므로 최근에 가장 오랫동안 사용하지 않은 페이지는 C
  - 그러므로 B-D-A 순으로 교체됨



![](https://imgur.com/cICkfGO.png)

![](https://imgur.com/Ke6ekLk.png)

- 페이징 크기
  - 페이지 크기가 작을 경우
    - 많은 페이지수가 필요
    - 페이지 사상표의 공간은 더 많이 요구됨
    - 알찬 워킹 셋을 유지할 수 있음
  - 페이지 크기가 클 경우
    - 페이지 단편화로 인해 많은 기억공간을 낭비
    - 페이지 사상표의 공간 크기는 줄어듬
    - 전체적인 디스크 접근 시간이 줄어들어
    - 이동(입출력) 효율이 좋아짐
    - 실제 프로그램 수행과 무관한 내용이 포함될 수 있음

---

### 5장.












