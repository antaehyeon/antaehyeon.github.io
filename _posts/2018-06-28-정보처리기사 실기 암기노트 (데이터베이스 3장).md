---
layout: post
title:  "[정보처리기사]실기 암기노트 데이터베이스 3장"
subtitle:   "정보처리기사"
categories: doc
tags: 정보처리기사
comments: true
---

### 정보처리기사 실기 암기노트 (데이터베이스)

### 3장. SQL

1. #### DDL(Data Definition Language)의 개념

   `스키마` `도메인` `테이블` `뷰` `인덱스` `정의` `변경` `제거` `언어`

   `메타데이터` `시스템 카탈로그`

   `CREATE` `ALTER` `DROP`

   

   1. CREATE SCHEMA `스키권을 인증할 사람(AUTH ORI ZATION) 필요`

      `CREATE SCHEMA 스키마명 AUTHORIZATION 사용자_ID;`

      

   2. CREATE DOMAIN
      도메인은 도타(**도메인명 + 데이터타입**), 도타는 **기본(디폴트**)이 잘되있음, 인성이 쓰레기라 **제약**도 큼, 그래서 **확인(CHECK)** 해야됨

      ```sql
      CREATE DOMAIN 도메인명 데이터_타입
      	[DEFAULT 기본값]
      	[CONSTRAINT 제약조건명 CHECK (범위값)];
      ```

      ```sql
      CREATE DOMAIN SEX CHAR(1)
      	DEFAULT '남'
      	CONSTRAINT VALID-SEX CHECK (VALUE IN('남', '여'));
      ```

   3. CREATE TABLE `프라이머리` `고유` `포린키` `옵션 두개 DELETE UPDATE` `제약조건 ` `CHECK`

      ```sql
      CREATE TABLE 테이블명
      	(속성명 데이터_타입 [NOT NULL], ...
      	[, PRIMARY KEY (기본키_속성명, ...)]
      	[, UNIQUE (대체키_속성명, ...)]
      	[, FOREIGN KEY (외래키_속성명, ...)
      		REFERENCES 참조테이블(기본키_속성명, ...)]
      		[ON DELETE 옵션]
      		[ON UPDATE 옵션]
          [, CONSTRAINT 제약조건명][CHECK (조건식)]);
      ```

      - 속성명에 `NOT NULL` 적용 가능
      - 기본키 `PRIMARY KEY`
      - 대체키로 사용할 속성(집합) `UNIQUE` `속성들이 최소성을 만족시켜야함`
      - `FOREIGN KEY ~ REFERENCES ~ ` `외래키` `참조무결성` `CASCADE`
      - `ON DELETE` `NO ACTION` `CASCADE` `SET NULL` `SET DEFAULT`
      - `ON UPDATE` `NO ACTION` `CASCADE` `SET NULL` `SET DEFAULT`
      - `CONSTRAINT` `제약조건명이 없을경우 CHECK만 사용가능`

      ![](https://i.imgur.com/Mj7pWS6.png)

      

   4. CREATE VIEW `VIEW는 AS SELECT문이 따라온다 ASS`

      ```sql
      CREATE VIEW 뷰명[(속성명[, 속성명, ...])]
      AS SELECT문;
      ```

      SELECT문을 서브쿼리로 사용

      SELECT문의 결과로서 뷰를 생성

      UNION 이나 ORDER BY절을 사용할 수 없음

      ```
      CREATE VIEW 안산고객(성명, 전화번호)
      AS SELECT 성명, 전화번호
      FROM 고객
      WHERE 주소 = '안산시';
      ```

   

   5. CREATE INDEX `검색을 빠르게` `보조적인 데이터 구조` `I-O-T INDEX-ON-TABLE NAME`

      ```sql
      CREATE [UNIQUE] INDEX <인덱스명>
      	ON 테이블명 ({속성명 [ASC | DESC] [,속성명 [ASC | DESC]]})
      	[CUSTER];
      ```

      - UNIQUE 이 사용됬으면, 중복값이 없는 속성으로 인덱스를 생성 (없으면 중복값 허용)

      - 〈고객〉테이블에서 **UNIQUE**한 특성을 갖는 **고객번호 속성**에 대해 **내림차순**으로 정렬하여 '**고객번호_idx**' 라는 이름으로 **인덱스**를 정의하시오.

        ```sql
        CREATE UNIQUE INDEX 고객번호_idx
        	   ON 고객(고객번호 DESC);
        ```

        

   6. CREATE TRIGGER `입력` `갱신` `삭제` `이벤트가 발생할 때마다` `자동적으로 수행되는 사용자 프로시저`

      `무결성 제약조건 구현` `관련 테이블의 데이터 일치`

      `트리거명 AB IUD ON 테이블명` `트리거가 언제 실행되게 할것인지?` `무슨 작업을 할것인지?` `어떤 테이블에서?`

      `REFERENCING NO TABLE AS 테이블명`

      `FOR EACH ROW`

      `WHEN 조건식`

      `트리거 BODY(BEGIN-END)`

      ```sql
      CREATE TRIGGER 트리거명 [동작시기 옵션][동작 옵션] ON 테이블명
      REFERENCING [NEW | OLD] TABLE AS 테이블명
      FOR EACH ROW
      WHEN 조건식
      트리거 BODY
      ```

      - 동작시기 `AFTER` `테이블이 변경된 후` `BEFORE` `테이블이 변경되기 전`
      - 동작옵션 `INSERT` `DELETE` `UPDATE`
      - 테이블 선택옵션 `NEW` `OLD`
      - `WHEN` 조건
      - 트리거 `BEGIN - END`

      ```sql
      CREATE TRIGGER 학년정보_tri BEFORE INSERT ON 학생
      REFERENCING NEW TABLE AS 학생
      FOR EACH ROW
      WHEN new_table.학년 = ''
      BEGIN
      	SET new_table.학년 = '신입생';
      END;
      ```

       

   7. ALTER TABLE `DC - DROP COLUMN`

      ```sql
      ALTER TABLE 테이블명 ADD 속성명 데이터_타입 [DEFAULT '기본값'];
      ALTER TABLE 테이블명 ALTER 속성명 [SET DEFAULT '기본값'];
      ALTER TABLE 테이블명 DROP COLUMN 속성명 [CASCADE];
      ```

      ```sql
      〈학생〉테이블에 최대 3문자로 구성되는 학년 속성을 추가하는 SQL문
      ALTER TABLE 학생 ADD 학년 VARCHAR(3);
      ```

       

   8. DROP

      `DROP` `SCHEMA, DOMAIN, TABLE, VIEW, INDEX, TRIGGER` `[CASCADE | RESTRICT];`

      `DROP ` `CONSTRAINT` `제약조건명;`

      `RESTRICT` 다른 개체가 제거할 개체를 참조중일 경우 제거가 취소

      ```sql
      〈학생〉테이블을 제거하는 SQL문을 작성하시오. 단, 〈학생〉 테이블을 참조하는 모든 데이터도 함께 제거한다.
      DROP TABLE 학생 CASCADE;
      ```

      

   9. 오답노트

      ```sql
      내가 쓴 답
      CONSTRAINT sex_ck CHECK (sex = ‘f’ OR sex = ‘m’;),
      정답
      CONSTRAINT sex_ck CHECK (sex = ‘f’ or sex = ‘m’),
      ```

      제약조건 CONSTRAINT ~ CHECK 안에 세미콜론(;) 이 들어가지 않는다!

      ```sql
      내가 쓴 답
      CONSTRAINT id_fk CHECK ( FOREIGN KEY id REFERENCES doctor.doc_id; ));
      정답
      CONSTRAINT id_fk FOREIGN KEY (id) REFERENCES doctor(doc_id));
      ```

      외래키가 제약조건으로 들어간 경우, CHECK 생략 이후 id 는 전부 괄호() 를 사용한다.

      ```
      내가 쓴 답
      FOREIGN KEY (dept) REFERENCES Department(name),
      	ON DELETE SET NULL,
      	ON UPDATE CASCADE );
      정답
      FOREIGN KEY(dept) REFERENCES Department(name)
      	ON DELETE SET NULL
      	ON UPDATE CASCADE );
      ```

      외래키 부분에서의 ON DELETE, ON UPDATE 로 이루어지는 부분은 콤마(,) 를 찍지 않는다.

      ```
      내가 쓴 답
      AS SELECT id, Course.name, Instructor.name
      정답
      AS SELECT Course.id, Course.name, Instructor.name
      ```

      VIEW 를 정의할 때, 테이블이 나와있는 것이 아니면 `테이블.속성` 으로 표시한다.

      그리고 맨 뒤에 그냥 세미콜론(;) 넣어주면 된다.

      ```
      내가 쓴 답
      CREATE UNIQUE INDEX Stud_idx
      	ON Student(ssn) ASC;
      정답
      CREATE UNIQUE INDEX Stud_idx
      	On Student(ssn, ASC);
      * ASC는 생략할 수 있음
      ```

      INDEX 정의에서 I-O-T (괄호안에 모두 넣고 끝남)

      ```sql
      내가 쓴 답
      CONSTRAINT VALID-직위 VALUE IN(‘사원’, ‘대리’, ‘과장’, ‘부장’, ‘이사’, ‘사장’);
      정답
      CONSTRAINT VALID-직위 CHECK VALUE IN (...);
      ```

      CONSTRAINT - CHECK 는 항상! (외래키 사용할 때만 제외)

      ```sql
      CREATE ( ) 월급_trg AFTER UPDATE ON 급여
      	REFERENCING OLD TABLE AS old_tbl NEW TABLE AS new_tbl
      	FOR EACH ROW
      	WHEN old_tbl.직위 =new_tbl.직위
      	BEGIN
      		UPDATE 사원 SET 월급 = new_tbl.기본급 + new_tbl.성과급;
      	END;
      ```

      ```sql
      내가 쓴 답
      CREATE SCHEMA 개인정보 AUTHORIZATION id=‘장발장’;
      정답
      CREATE SCHEMA 개인정보 AUTHORIZATION '장발장';
      ```




2. #### SQL-SELECT

   1. SELECT문의 일반 형식

      ```sql
      SELECT [PREDICATE] [테이블명.]속성명[AS 별칭][, [테이블명.]속성명, ...]
      FROM 테이블명[, 테이블명, ...]
      [WHERE 조건]
      [GROUP BY 속성명[, 속성명, ...]]
      [HAVING 조건]
      [ORDER BY 속성명 [ASC|DESC][, 속성명 [ASC|DESC], ...]];
      ```

      - PREDICATE `검색할 튜플을 제한할 목적으로 사용되는 조건`
        - `ALL` - 모든 튜플 검색 (기본값)
        - `DISTANCT` - 중복된 튜플 제거
        - `DISTANCTROW` - 튜플 전체값을 대상으로 중복된 튜플 제거
      - 2개 이상의 테이블을 검색할 때 `테이블명.속성명` 으로 사용
      - `AS` 다른 제목으로 표현
      - `FROM` `WHERE`
      - `GROUP BY` : 특정 속성을 기준으로 그룹화하여 검색할 때 사용, 그룹함수와 함께 사용
      - `HAVING` : 그룹에 대한 조건
      - `ORDER BY`
      - ![](https://i.imgur.com/NKAie34.png)
      - ![](https://i.imgur.com/jiaBiDZ.png)
      - ![](https://i.imgur.com/kS9G2QR.png)
      - WHERE 조건문에 `IS NULL` 또는 `IS NOT NULL` 을 사용할 수 있다
      - ![](https://i.imgur.com/3f7CHMb.png)
      - ![](https://i.imgur.com/QkuaybV.png)
      - ![](https://i.imgur.com/lUcHWc0.png)
      - GROUP BY 는 해당 속성의 중복을 전부 제거하는 것인가? `그룹으로 묶는다` 이런느낌
      - ![](https://i.imgur.com/ivQ02z6.png)
      - IN, NOT IN 의 차이 및 복수테이블과 하위 질의에 대한 차이점 인식하기
      - 하위질의 괄호 안에 세미콜론(;) 넣지 않음
      - ![](https://i.imgur.com/3f7CHMb.png)
      - ![](https://i.imgur.com/kpcBX2a.png)
        - 2개의 테이블의 속성들이 SELECT에 들어있을 때, `복수 테이블`
        - 1개씩 SELECT에 들어있을 때, `하위질의`

       

   2. #### 기출 따라잡기

      - ![](https://i.imgur.com/S1rVYzj.png)
        - 괄호가 항상 중요함! `중복되는 레코드는 한번만 표시하고` = DISTINCT

          ```sql
          내답 : SELECT name (...)
          정답 : SELECT DISTINCT name (...)
          ```

      - ![](https://i.imgur.com/ygJIrSG.png)

        - 결과 테이블에 네이밍이 다른것이 아니면 AS 절은 빼는식으로 작성하자

          ```sql
          내답 : SELECT SUM(psale) AS 합계
          정답 : SELECT SUM(psale)
          ```

      - ![](https://i.imgur.com/wxmdQX4.png)

        - ORDER BY 구문을 정확히 알 것

          ```sql
          내답 : ORDER BY ASC;
          정답 : ORDER BY name [ASC];
          ```

      - ![](https://i.imgur.com/fEYIvI5.png)

      - ![](https://i.imgur.com/5MqucdA.png)

        

        - HAVING 조건에 대해서 조금 더 명확하게

          ```sql
          내답 : GROUP BY 결제여부
          HAVING COUNT(결제여부);
          
          정답 : GROUP BY 결제여부;
          ```

          





















